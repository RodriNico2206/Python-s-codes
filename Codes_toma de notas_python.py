# -*- coding: utf-8 -*-
"""Codigos_Curso_Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dsPbuGludlro0OwQ4OwQWHP0f6ZhJ913
"""

#variable entera
int_Var=1
#variable flotante
float_Var=2.03
#variable string o caracteres
str_Var='hola'
#variable booleana
bool_Var=True

#operadores
#suma
h=5 + 10
print(h)
#resta
i=10 - 5
print(i)
#multiplicación
j=2 * 3
print(j)
#división
k=10 / 2
print(k)
#división entera (devuelve la parte enter del resultado de la división)
l=3 // 2
print(l)
#potencia
m=2 ** 3
print(m)
#Modulo (devuelve el resto de la división)
n=4 % 2
print(n)

#Declaración de constantes aplicable a cualquier tipo de dato
const_Var=2
VAR=2

#dejar espacio entre operadores aritmeticos para el codigo sea mas legigle
#orden de prioridad en operadores aritmeticos 1- parentesis, 2- potencias
#3- multiplicaciones, 4-sumas y restas

#operadores condicionales o de comparación, estos devuelven un resultado booleano
# (==) igual que
# (> o <) mayor que o menor que
# (>= o <=) mayor o igual que, menor o igual que

#operadores logicos, estos se usan en conjunto con los operadores condicionales
# (and, y, &) x>5 & y<10
# (or, o, || ) x>5 | y<10 

x=10
y=11

x>5 and y<10 #operador and
x>5 or y<10 #operador or

#(.3) especifica la cantidad de decimales a mostrar del valor flotante 
# print("El area del triangulo es:  %.3f"%(float_Area)

# Al usar %d lo que que se obtiene como resultado es la parte entera de la división
#int_Parte_Entera = int_Total / 1000
#print("Parte Entera  (6E): %d " %(int_Parte_Entera ))

#Listas: pueden almacenar enteros, booleanos, flotantes y otras listas
#declaracion de listas
#list_Nombre_Nombre = [dato1, dato2, dato3, ..., dato n]

list_Cosas = ['hola','soy',[3,4],5]

#indexación: se accede a los elementos de la lista de la siguiente manera
#print(list_Cosas [1])

#se accede a los ultimos elementos de la lista usando numeros negativos 
# print(list_Cosas [-1]) el uso numeros mágicos debe evitarse

#\n permite insertar un espacio en la siguiente linea, quedando una linea vacia

INICIO = 0
FIN = -1
INDICE = 2
SALTO = 1

#       PARTICIONADO DE LISTAS
#Lista(inicio:fin)
#print(list_Cosas [INICIO:FIN]) *['hola', 'soy', [3, 4], 5]
#print(list_Cosas [INICIO:]) *['hola', 'soy', [3, 4], 5]

#lista(inicio:fin:salto)
print(list_Cosas [INICIO::INDICE])

#       PARTICIONADO DE LISTAS POR DEFECTO
#Lista(:)
#print(list_Cosas [:]) *['hola', 'soy', [3, 4], 5]
#print(list_Cosas [INICIO:]) *['hola', 'soy', [3, 4], 5]
#print(list_Cosas [:FIN]) *['hola', 'soy', [3, 4], 5]
#print(list_Cosas [::SALTO]) *['hola', 'soy', [3, 4], 5]
#print(list_Cosas [::INDICE]) *['hola', [3, 4]]

list_lista_vacia = [] #lista vacia

#otra forma de declarar lista
list_lista2 = ['hola',
               'de nuevo',
               35.5,
               6
               ]

#agregar nuevo elemento a la lista
#list_NOMBRE_LISTA.append(dato)

#agregar varios elementos en un lista
#list_NOMBRE_LISTA.extend([dato1, dato2, ..., dato n])

#longidtud de una lista
#len(list_NOMBRE_LISTA)

#remover un elemento de la lista pasado como parametro
#list_NOMBRE_LISTA.remove(dato)

#remueve el elemento de una lista a partir de su indice
#list_NOMBRE_LISTA.pop(indice)

#devuelve el indice de un elemento pasado como parametro
#list_NOMBRE_LISTA.index(elemento)

#devuelve cuantas veces se repite en la lista un elemento pasado como parametro
#list_NOMBRE_LISTA.count(elemento)

#invierte los elementos de una lista
#permite trabajar de dos manera, por el metodo:
# -fila(1ero que llega 1ero en ser atendido)
# -pila(ultimo en llegar 1ero en ser atendido)

#list_NOMBRE_LISTA.reverse()

#           MANEJO DE CADENAS

#metodo join: une los elementos de una lista en una linea de caracteres
#se especifica el caracter por el cual separamos los elementos de una lista
#string = 'caracter'.join(list_NOMBRE_LISTA)

#metodo split: coloca los elementos en un string, separados por algun caracter, en una lista
#list_Nueva_lista = string.split('caracter de separación')

#       EXTRACCION DE SUBSTRINGS
#pueden extraerse elementos de una cadena de caracteres de la misma manera que
#se particionan listas
#str_cadena = 'abcdefghijk'
#print(str_cadena [INICIO:FIN])

#Por último, en caso de trabajar con bloques de subcodigo, se debe ejecutar el
#bloque de declaracion de variables y constantes para evitar errores en la consola
#La otra opcion es declarar las variables y constantes en el bloque a ejecutar
#para de esta manera evitar errores en la consola

#       METODO DE ANALISIS
# -cadena.count(cadena): cuenta cuantas veces se repite el elemento dentro de la
#cadena
# -cadena.find(cadena): retorna la posición en la que se encuentra el elemento
#pasado como parametro. Si no lo encuentra devuelve -1
# -cadena.index(cadena): retorna la posición en la que se encuentra el elemento
#pasado como parametro. Si no lo encuentra se produce un error
# -cadena.startswith(cadena): devuelve true o false si una cadena
#comienza con el elemento pasado como parametro
# -cadena.endswith(cadena): devuelve true o false si una cadena
#termina con el elemento pasado como parametro

#           METODO DE VALIDACION
# cadena.isdigit(): devuelve true o false si una cadena es numerica
# cadena.isalnum(): devuelve true o false si una cadena es alfanumerica
# cadena.isalpha(): devuelve true o false si una cadena es alfabetica
# cadena.isdigit(): devuelve true o false si una cadena es numerica
# cadena.isspace(): devuelve true o false si una cadena solo tiene espacios en blanco

#           METODOS DE TRANSFORMACIÓN
# - cadena.upper(): convierte una cadena a mayusculas
# - cadena.lower(): convierte una cadena a minusculas
# - cadena.replace('cadena', 'cadena nueva'): reemplaza una cadena por otra
# - cadena.center(longitud, caracter de relleno): agrega caracteres de relleno a
# una cadena de modo que esta queda centrada con la misma cantidad a ambos lados
# - cadena.ljust(longitud, caracter de relleno): agrega caracteres de relleno a
# una cadena de modo que esta queda alineada a la izquierda con la cantidad
# de estos a la derecha
# - cadena.rjust(longitud, caracter de relleno): agrega caracteres de relleno a
# una cadena de modo que esta queda alineada a la derecha con la cantidad
# de estos a la izquierda

#                     ACLARACION
# %(numero)s: permite reservar un cuerto numero de espacios para la cadena de
#que alli se colocara
# forma de escribir un str en forma de tabla: str_tabla = """\  contenido  """\ 
# forma de imprimir con print un str en forma de tabla: print("\n" + str_tabla + "\n" )

#                     TUPLAS Y CONSTANTES
# son un conjunto de datos inmutables, es decir, que no pueden modificarse sus
#valores ni agregar nuevos datos.
#Declaracion de tuplas
# tuple_Tupla = ('hola', 2, true, 1.2) #FORMA 1
# t_Tupla = ('hola', 2, true, 1.2) #FORMA 2

#se accede a los valores de un tupla de igual manera que en listas
# t_Tupla[0] #Se accede al elemento 0

#                    DICCIONARIOS
# conjunto de elementos que se poseen una clave (está entre '') y un valor sepa
#rados por ":"

#declaracion
# dic_Diccionario = {'ab':1,'cd':2,'ef':3}

# diccionario.keys(): devuelve una lista con todas las claves del diccionario
# diccionario.items(): devuelve una lista con todos los elementtos del diccio
#nario, es decir, el par (clave, valor)

#                         METODO FORMAT
# str_Lengusjel- "Pseudocodigo"
# str_Lenguaje2 = "Python"

# manera de colocar valores dentro de strings y mostrarlos por medio del print
# print("1) El lenguaje es {0} .\n".format(str_Lenguaje1) )
# print("2) Los lenguajes son: {0} y {1} .\n".format(str_Lenguajel, str_Lenguaje2 )
# print("3) Los languajes son: {} y {}.\n".format (str_Lenguaje1, str_Lenguaje2 ) )
# print("4) Los lenguajes son: (a) y (b).\n".format (a = str_Lenguajel, b = str_Lenguaje2) )
# print("5) Intercalado: {0}, {1}, {0}, {1}. Va".format(str_Lenguajel, str_Lenguaje2 ) )

#                       ALINEACION DE CARACTERES
# Alineado a la izquierda
# '<': alinea a la izquierda, generalaente se omite ya que es la opción por
# defecto en la mayoria de los objetos
# {:<X} : Muestra el contenido alineado a la izquierda, ocupando X caracteres
# a la derecha de la cadena



# Alineado a la izquierda
# '>': Alinea a la derecha
# {:>X} : Muestra el contenido alineado a la derecha, ocupando X caracteres
# a la izquierda de la cadena



# Alineado al centro
# '^': Alinea al centro
# {:^X} : Muestra el contenido centrado, ocupando X caracteres a ambos lados de
# la cadena

#Ejercicio 1

## *****************************************************************************
## |       Producto       |     Descripcion      |  Cantidad   |      Precio   |
## *****************************************************************************
## |      SmartPhone      |  Iphone 12 Pro Max   |      1      |       2000    |
## |      SmartPhone      |  Iphone 11 Pro Max   |      1      |       1500    |
## |      SmartPhone      |  Iphone 10 Pro Max   |      1      |       1200    |
## |      SmartPhone      |  Iphone 09 Pro Max   |      1      |       1000    |
## *****************************************************************************
## |                                                  TOTAL    |       5700    |
## *****************************************************************************

list_Trama = ["Producto", "Descripcion", "Cantidad", "Precio"]

list_Producto1 = ["2000", "1", "Iphone 12 pro Max", "Smartphone"]
list_Producto2 = ["1500", "1", "Iphone 12 pro Max", "Smartphone"]
list_Producto3 = ["1200", "1", "Iphone 12 pro Max", "Smartphone"]
list_Producto4 = ["1000", "1", "Iphone 12 pro Max", "Smartphone"]

PRODUCTO = 0
DESCRIPCION = 1
CANTIDAD = 2
PRECIO = 3


#invierto listas
list_Producto1.reverse()
list_Producto2.reverse()
list_Producto3.reverse()
list_Producto4.reverse()

#VARIABLES
float_total=float( list_Producto1[PRECIO] ) + float( list_Producto2[PRECIO] ) + float( list_Producto3[PRECIO] ) + float( list_Producto4[PRECIO] ) 
str_formato = 'TOTAL'.rjust(66, ' ')

print( ''.center(93, '*') )

print('| {:^20} | {:^20} | {:^20} | {:^20} |'
.format(list_Trama[PRODUCTO],
        list_Trama[DESCRIPCION],
        list_Trama[CANTIDAD],
        list_Trama[PRECIO] ) )

print( ''.center(93, '*') )

print('| {:^20} | {:^20} | {:^20} | {:^20} |'
.format(list_Producto1[PRODUCTO],
        list_Producto1[DESCRIPCION],
        list_Producto1[CANTIDAD],
        list_Producto1[PRECIO] ) )

print('| {:^20} | {:^20} | {:^20} | {:^20} |'
.format(list_Producto2[PRODUCTO],
        list_Producto2[DESCRIPCION],
        list_Producto2[CANTIDAD],
        list_Producto2[PRECIO] ) )

print('| {:^20} | {:^20} | {:^20} | {:^20} |'
.format(list_Producto3[PRODUCTO],
        list_Producto3[DESCRIPCION],
        list_Producto3[CANTIDAD],
        list_Producto3[PRECIO] ) )

print('| {:^20} | {:^20} | {:^20} | {:^20} |'
.format(list_Producto4[PRODUCTO],
        list_Producto4[DESCRIPCION],
        list_Producto4[CANTIDAD],
        list_Producto4[PRECIO] ) )

print( ''.center(93, '*') )

print('| {:^20}   {:^20}   {:^20} | {:^20} |'
.format('',
        '',
        'TOTAL',
        float_total ) )

print( ''.center(93, '*') )

#Ejercicio 2

## *****************************************************************************
## |       Producto       |     Descripcion      |  Cantidad   |      Precio   |
## *****************************************************************************
## |      SmartPhone      |  Iphone 12 Pro Max   |      1      |       2000    |
## |      SmartPhone      |  Iphone 11 Pro Max   |      1      |       1500    |
## |      SmartPhone      |  Iphone 10 Pro Max   |      1      |       1200    |
## |      SmartPhone      |  Iphone 09 Pro Max   |      1      |       1000    |
## *****************************************************************************
## |                                                  TOTAL    |       5700    |
## *****************************************************************************

tuple_Trama = ('Producto', 'Descripcion', 'Cantidad','Precio')

str_Producto1 = 'Smartphone|Iphone 12 Pro Max|1|2000'
str_Producto2 = 'Smartphone|Iphone 11 Pro Max|1|1500'
str_Producto3 = 'Smartphone|Iphone 10 Pro Max|1|1200'
str_Producto4 = 'Smartphone|Iphone 09 Pro Max|1|1000'

PRODUCTO = 0
DESCRIPCION = 1
CANTIDAD = 2
PRECIO = 3


#convierto str a list
list_Producto1 = str_Producto1.split('|')
list_Producto2 = str_Producto2.split('|')
list_Producto3 = str_Producto3.split('|')
list_Producto4 = str_Producto4.split('|')

#print(str(list_Producto1) + '\n' + str(list_Producto2) + '\n' + str(list_Producto3) + '\n' + str(list_Producto4) + '\n' )

#VARIABLES
float_total=float( list_Producto1[PRECIO] ) + float( list_Producto2[PRECIO] ) + float( list_Producto3[PRECIO] ) + float( list_Producto4[PRECIO] ) 
str_formato = 'TOTAL'.rjust(66, ' ')

print( ''.center(93, '*') )

print('| {:^20} | {:^20} | {:^20} | {:^20} |'
.format( tuple_Trama[PRODUCTO],
        tuple_Trama[DESCRIPCION],
        tuple_Trama[CANTIDAD],
        tuple_Trama[PRECIO] ) )

print( ''.center(93, '*') )

print('| {:^20} | {:^20} | {:^20} | {:^20} |'
.format(list_Producto1[PRODUCTO],
        list_Producto1[DESCRIPCION],
        list_Producto1[CANTIDAD],
        list_Producto1[PRECIO] ) )

print('| {:^20} | {:^20} | {:^20} | {:^20} |'
.format(list_Producto2[PRODUCTO],
        list_Producto2[DESCRIPCION],
        list_Producto2[CANTIDAD],
        list_Producto2[PRECIO] ) )

print('| {:^20} | {:^20} | {:^20} | {:^20} |'
.format(list_Producto3[PRODUCTO],
        list_Producto3[DESCRIPCION],
        list_Producto3[CANTIDAD],
        list_Producto3[PRECIO] ) )

print('| {:^20} | {:^20} | {:^20} | {:^20} |'
.format(list_Producto4[PRODUCTO],
        list_Producto4[DESCRIPCION],
        list_Producto4[CANTIDAD],
        list_Producto4[PRECIO] ) )

print( ''.center(93, '*') )

print('| {:^20}   {:^20}   {:^20} | {:^20} |'
.format('',
        '',
       'TOTAL',
        float_total ) )

print( ''.center(93, '*') )

#Ejercicio 1

##    Introducir un numero por teclado y que se muestre un mensaje indicando
##    si es par o impar.

#declaración de variables
int_Numero = 0

int_Numero = int( input('Ingrese un nº entero: ') )

if int_Numero % 2 == 0:
  print('El nº {} es par'.format(int_Numero) )
else:
  print('El nº %d es impar'%(int_Numero) )

#Ejercicio 2

##    Introducir un numero por teclado y que se muestre un mensaje indicando
##    si es multiplo de 3.

#declaración de variables
int_Numero = 0

int_Numero = int( input('Ingrese un nº entero: ') )

if int_Numero % 3 == 0:
  print('El nº {} es múltiplo de 3'.format(int_Numero) )
else:
  print('El nº %d no es múltiplo de 3'%(int_Numero) )

#       BUCLE WHILE
#Sentencia WHILE:

#HACER MIENTRAS (condicion)
#  instrucciones
#FIN del MACER

#Ejemplo
#while int_Indice < len(Mi_lista)
#    print(Mi_lista[int_Indice])
#    int_Indice = int_Indice + 1


#       BUCLE FOR IN

#Sentencia FOR IN:

#PARA CADA ELEMENTO HACER
    #instrucciones
#FIN del HACER

#for (variable) in Nombre_lista
#  print (nombre) I


#       BUCLE FOR IN RANGE
#Hace una serie de tareas para ciertos elementos dentro de un rango 

#PARA CADA ELEMENTO EN EL RANG0 HACER
#   instrucciones
#FIN del HACER

#Ejemplo:

#for potencia in range(0,11)
#    resultado numero *" potencia
 #   print(d elevado a Sd es Sd"s(numero, patencia,resultado)

# EJERCICIO 1 - ESTRUCTURAS REPETITIVAS

#Introducir tantas frases por teclado como deseemos y contarlas

#variables
char_resp = 'S'
char_frase = ''
int_cont = 0

while char_resp == 'S':
    char_frase = input('Introduzca una frase: ')
    int_cont = int_cont + 1
    
    char_resp = input('Desea introducir otra frase (S/N): ')

print('Nº de frases ingresadas: {}'.format(int_cont))

# EJERCICIO DE BUCLES ANIDADOS

# Hacer un pseudocódigo que simule el funcionamiento de un Reloj Digital
# y que permita ponerle la hora.

import time

horas    = int(input('Introduce horas: '))
minutos  = int(input('Introduce minutos: '))
segundos = int(input('Introduce segundos: '))
 
print("")
print("%02d:%02d:%02d" %(horas,minutos,segundos))
 
# Hacer_1 Mientras TRUE
while True:
    # Hacer_2 Mientras horas < 24
    while horas < 24:
        # Hacer_3 Mientras minutos < 60
        while minutos < 60:
            # Hacer_4 Mientras segundos < 60
            while segundos <60:
                print("%02d:%02d:%02d" %(horas,minutos,segundos))
                segundos = segundos + 1
                time.sleep(1)
            # fin del Hacer_4
            minutos = minutos + 1
            segundos = 0
        # fin del Hacer_3
        horas = horas + 1
        minutos = 0
    # fin del Hacer_2
    horas = 0
# fin del Hacer_1

# EJERCICIO Variables Auxiliares
# Introducir dos números naturales por teclado. Imprimir los numero naturales
#que hay entre ambos números empezando por el mas pequeño.

#VARIABLES  
int_num1 = 0
int_num2 = 0
int_aux = 0
int_cont = 0
int_mayor = 0
int_menor = 0

int_num1 = int (input('Ingrese el 1er número: '))
int_num2 = int (input('Ingrese el 2do número: '))

if int_num1 > int_num2 :
    int_mayor = int_num1
    int_menor = int_num2
else :
    int_mayor = int_num2
    int_menor = int_num1

#print('El mayor es: {}. El menor es: {}'.format(int_mayor,int_menor))

int_cont = int_menor

while int_cont <= int_mayor and int_cont >= int_menor :
    print(int_cont)
    int_cont = int_cont + 1

#EJERCICIO Banderas de Estado

# Imprimir 10 veces de una forma alternativa 'Hola' y 'Adios'

bool_band = 0
int_cont = 1

while int_cont <= 10:
  if bool_band == 0:
    print('Hola')
    bool_band = 1
    int_cont = int_cont + 1
  else:
    print('Adiós')
    bool_band = 0
    int_cont = int_cont + 1

# FUNCIONES
# el nombre de las funciones debe ir preferiblemente en minuscula

#[tipo de var. que devuelve]_FUNCION (var1, var2, ..., var n):
# Instrucciones
# Return (variable)     #la función devuelve como resultado la var. especificada
#FIN DE FUNCION

#NOTA
# (1) si la función no vevuelve ninguna variable, no ira un tipo de variable
#delante de su nombre

# (2) var1, var2, ..., var n: variables que recibe la función

# (3) al declarar una función es bueno realizar el "docstring" de la misma. En el se
# detallan las operaciones o resultados que se obtienen de ella

# (4) al pasar parametros a una función los mismos se harán en el sgte orden:
# P fijos (variables int, str, etc) - P. Arbitrarios (listas o tuplas, diccionarios)

# (5) Si se requiere suministrar más de tres variables a una funcion,
# conviene hacerlo en una lista o diccionario que de manera individual

# (6) PASAJE DE LISTAS, TUPLAS Y DICCIONARIOS A FUNCIONES:
# nomb_funcion(nom_var, *list (o tupla), **dic)


#Forma de uso
#instrucciones
#Llamar FUNCION
#instrucciones

# Declaración de funciones:
#def main():
#  pass

#def mi_funcion():
#  print("\nMANEJO DE FUNCIONES\n")

#def mi_menu ():
#  print ("- Escoge una opción: \n")
#  print ("1) SUMA. \n")
#  print ("2) RESTA. \n")
#  print ("3) MULTIPLICACION. \n")
#  print ("4) DIVISION. \n")

#LLAMADA DE LAS FUNCIONES
#main()
#mi_funcion()
#mi_menu ()

# print((nomb_funcion).__name__): Imprime el nombre de la función
# print((nomb_funcion).__doc__): Imprime las operaciones o resultados
#que se obtienen de la función

#       RECURSIVIDAD
# esto implica llamar a una función dentro de la misma para, por ej, realizar
# validaciones

#       VALIDACION DE DATOS
# implica obligar al usuario a que ingrese los datos que esperamos, antes que
# esperar que este los ingrese correctamente de forma natural.


#        TRY-EXCEPT
# el mismo es utilizado para evitar la ocurrencia de errores en consola


#try:         <--- INTENTAMOS REALIZAR LA SENTENCIA QUE PODRIA TENER 1 ERROR
#  int edad int(Input("Introduce tu edad: "))
#  print("Tu edad es: %d\n" (int edad))

#except ValueError, ex: <--- EN CASO DE 1 ERROR ESPECÍFICO ARROJAMOS EL SGTE MENSAJE
#  print("\nExcepcion Capturada\n")
#  print (ex)

#except:      <--- EN CASO DE CUALQUIER ERROR ARROJAMOS EL SGTE MENSAJE
#  print("\nNo has introducido valores numericos. Intenta de nuevo\n")
#  edad()

#     CODIGO LIMPIO
# El nombre de una variable, función o clase debe responder una serie de cuestiones básicas.
# Debe indicar por qué existe, qué hace y cómo se usa.
# Se debe elegir un nombre que especifique lo que se mide y la unidad de dicha medida

# Ejemplos de codigo limpio
diasTranscurridos = 0 # Forma CORRECTA
diasRestantes = 1 # Forma CORRECTA
diasFeriados = 10 # Forma CORRECTA


# Utiliza nombres descriptivos en lugar de nombres cortos:

#► Si contiene números usa palabras que acompañen cantidades:
#► Si la variable tiene valor booleano escribela como una pregunta:
#► Las listas, tuplas y diccionarios, por lo general, tienen varios elementos
# es por ello que se usan nombres en plural.



#       ESTILO WCODE EXTENDIDO
#El estilo WCODE ofrece más alternativas y detalles a la hora de declarar
#variables, que se adaptan al gusto del programador. Lo importante, una vez
#elegido el estilo, es mantenerlo a lo largo del programa para que este sea
#uniforme y no afecte la legibilidad.

#     DECLARACION DE VARIABLES


#► Variables del tipo Enteras:
int_Numero = 1000 # dato_Variable = valor
int_numero = 2000 # dato_variable = valor
i_numero = 3000 #d_variable = valor
iNumero = 4000 #dVariable = valor


#► Variables del tipo Float:
float_Numero = 23.6 # dato_Variable = valor
float_numero = 38.2 # dato_variable = valor
f_numero = 61.8 #d_variable = valor
fNumero = 79.0 #dVariable = valor


#► Variables del Tipo String:
str_Cadena "BOLETO" # dato_Variable = valor
str_cadena = "CINE" # dato_variable = valor
s_cadena = "TV"     #d_variable = valor
sCadena = "LIBROS" # dVariable = valor


#► Variables del tipo Booleanas:
bool_estado = True # dato_variable = valor
b_estado = False   #d_variable = valor
bEstado = True     #dVariable = valor
isEstado = False   # isVariable = valor

# DECLARACION DE LISTAS, TUPLAS Y DICCIONARIOS
# Se agregan los siguientes prefijos para identificar el tipo de colección:
# list : Identifica una lista.
# tuple: Identifica una Tupla.
# dict: Identifica un Diccionario.

# list_nombres = ['Mark', 'Steve', 'Bill', 'Elon']
# tuple_productos = ("Smartphone", "Tablet","TV")
# dict_servicios = {'ftp':21, 'ssh":22, 'smtp":25}

#         DECLARACION DE FUNCIONES
# Utiliza verbos con sustantivos, pueden ser nombres largos,
#lo importante es que se entienda lo que realiza la función.

#► Se agregan los siguientes prefijos a funciones que devuelven algún tipo de dato.
# def str_menu(): # Retorna una Cadena
# def int_operacion (): # Retorna un Entero
# def float_calculadora (): # Retorna un Flotante
# def list_crear_matriz (): # Retorna una Lista

#                 CALCULADORA FREELANCER - Enunciado:
# Un Freelancer desea saber cuánto puede cobrar por su trabajo semanal y
# mensualmente, para ello solo necesita establecer el precio de su trabajo por hora.
# Se estiman 40 horas de trabajo a la semana.
# Las Fórmulas para calcular el pago Semanal y Mensual son:
# 1) Pago_Semanal = (DolaresPorHora x 40)
# 2) Pago_Mensual = (DolaresPorHora x 160)

# RESOLUCIÓN
f_DolaresPorHora = 0.0
f_PagoSemanal = 0.0
f_PagoMensual = 0.0


f_DolaresPorHora = float( input('Ingrese precio de trabajo por hora [USD]: ') )
f_PagoSemanal = f_DolaresPorHora * 40
f_PagoMensual = f_DolaresPorHora * 160


print(''.center(50,'-'))
print('{}'.format('CALCULADORA FREELANCER'.center(50,' ')) )
print(''.center(50,'-'))

s_PagoSemanal = 'PAGO SEMANAL: '
s_PagoMensual = 'PAGO MENSUAL: '

print('>>> ' + s_PagoSemanal + '{}'.format(f_PagoSemanal) )
print('>>> ' + s_PagoMensual + '{}'.format(f_PagoMensual) )
print(''.center(50,'-'))



# ► Salida:

# ----------------------------------------
#      CALCULADORA FREELANCER (USD)      
# ----------------------------------------
# >>> Precio en dolares por Hora: 20
# ----------------------------------------
# >>> PAGO SEMANAL: 800.00
# >>> PAGO MENSUAL: 3200.00
# ----------------------------------------

# Promedio de Calificaciones - Enunciado:

# Imprime en pantalla una tabla con los nombres de los estudiantes y
# su promedio de notas.

# ► Variables:
# • datos: Almacena el nombre y el promedio de los alumnos.
# • encabezado: Almacena el encabezado del programa.

# ► Salida:

# +--------------------+----------+"
# |       NOMBRE       | PROMEDIO |
# +--------------------+----------+ 
# |Taylor C.           |      9.51|
# +--------------------+----------+
# |John G.             |      8.96|
# +--------------------+----------+
# |Maria S.            |      9.22|
# +--------------------+----------+
# |Juan C.             |      9.99|
# +--------------------+----------+
# |Anna A.             |      8.99|
# +--------------------+----------+
# |Mike T.             |      9.50|
# +--------------------+----------+
# |Pedro F.            |      9.99|
# +--------------------+----------+
# |Julia F.            |      8.99|
# +--------------------+----------+
# |Delia F.            |      9.89|
# +--------------------+----------+
# |Julio A.            |      7.50|
# +--------------------+----------+

#     RESOLUCION

l_alumnos = {'Taylor C.':9.51,'John G.':8.96,'Maria S.':9.22,
            'Juan C.':9.99,'Anna A.':8.99,'Mike T.':9.50,
            'Pedro F.':9.99,'Julia F.':8.99,'Delia F.':9.89,'Julio A.':7.50}

s_Encabezado = '''
+--------------------+----------+
|       NOMBRE       | PROMEDIO |
+--------------------+----------+
'''
print('+'+''.center(11,'-')+'+'+''.center(11,'-')+'+')
print('|{:^10} | {:^10}|'.format('NOMBRE','NOTA'))

for i_alumnos in l_alumnos:
  print('+'+''.center(11,'-')+'+'+''.center(11,'-')+'+')
  print('|{:<10} | {:>10}|'.format(i_alumnos,l_alumnos[i_alumnos]))

print('+'+''.center(11,'-')+'+'+''.center(11,'-')+'+')

s_encabezado1 = '''
              | {:<8} {:<8} {:<6} {:22} {:<11} {:6} |\
              '''

s_encabezado2 = '''
              +--------------------------------------------------------------------+\
              '''

d_DatosLenguajes = { 'Python': [1,3, '^','Python', 15.33, 4.47],
                    'C': [2,1, 'v','C', 14.08, -2.26],
                    'Java': [3, 2, 'v', 'Java', 12.13, 0.84],
                    'C++': [3, 4, '', 'C++', 8.01, 1.13],
                    'C#': [5, 5, '', 'C#', 5.37, 0.93],
                    'Visual Basic': [6, 6, '', 'Visual Basic', 5.23, 0.9],
                    'JavaScript': [7, 7, '', 'JavaScript', 1.83, -0.45],
                    'PHP': [8, 8, '', 'PHP', 1.79, 0.04],
                    'Assembly language': [9, 10, '^', 'Assembly language', 1.6, -0.06],
                    'SQL': [10, 9, 'v', 'SQL', 1.55, -0.18],
                    'Go': [11, 13, '^', 'Go', 1.23, -0.05],
                    'Swift': [12, 15, '^', 'Swift', 1.18, 0.04],
                    'R': [13, 11, 'v', 'R', 1.11, -0.45],
                    'MATLAB': [14, 16, 'v', 'MATLAB', 1.03, 0.03],
                    'Delphi/Object Pascal': [15, 17, '^', 'Delphi/Object Pascal', 0.9, -0.12],
                    'Ruby': [16, 14, 'v', 'Ruby', 0.89, -0.35],
                    'Classic Visual Basic': [17, 18, '^', 'Classic Visual Basic', 0.83, -0.18],
                    'Objective C': [18, 20, '^', 'Objective C', 0.81, -0.08],
                    'Perl': [19, 19, '', 'Perl', 0.79, -0.13],
                    'Groovy': [20, 12, 'vv', 'Groovy', 0.74, -0.76],                
                    }

print( s_encabezado2 )
print( s_encabezado1
      .format( 'Feb 2022', 'Feb 2021',
              'Change', 'Language', 'Ratings (%)', 'Change' ) )

for lenguajes in d_DatosLenguajes:
    print(s_encabezado1.format(d_DatosLenguajes[lenguajes][0],
          d_DatosLenguajes[lenguajes][1], d_DatosLenguajes[lenguajes][2],
          d_DatosLenguajes[lenguajes][3],d_DatosLenguajes[lenguajes][4],
          d_DatosLenguajes[lenguajes][5] ) )


print( s_encabezado2 )

# Secuencia de Fibonacci - Enunciado:

#Desarrollar un programa que genere la secuencia de Fibonacci.
#Se debe crear y llamar recursivamente a la función. Se debe calcular 
#la suma recursiva de los dos números anteriores
#(número-2) y (número-1). Mostrar el resultado de cada iteración en pantalla.

try:
  s_NTerminos = input(">>> Introduce el valor del termino 'n': ")
  Serie(s_NTerminos)
except:
  
  print('ERROR! Reingrese valor del termino "n": ')
  s_NTerminos = input(">>> Introduce el valor del termino 'n': ")
  Serie(s_NTerminos)


def Serie(s_NTermino):
  i_TerminoNmenos1, i_TerminoNmenos2, i_TerminoN = 1, -1, 0
  
  for i in range(0,int(s_NTermino) ):
   i_TerminoN = i_TerminoNmenos1 + i_TerminoNmenos2
   print('>>> F{} = {}'.format(i+1, i_TerminoN) )
   i_TerminoNmenos2 = i_TerminoNmenos1
   i_TerminoNmenos1 = i_TerminoN

# Factorial de un Número - Enunciado:

#Desarrollar un programa que genere el factorial de un número. Implementar y
#llamar a la funcion de forma recursiva.
#Mostrar el resultado de cada iteración en pantalla.

try:
  s_NFactorial = input(">>> Introduce el valor de 'n': ")
  Factoriales(s_NFactorial)
except:
  print('ERROR! Reingrese valor del termino "n"\n')
  s_NFactorial = input(">>> Introduce el valor del termino 'n': ")
  Factoriales(s_NFactorial)


def Factoriales(s_NFactorial):
  i_ResultadoFactorial = 1
  
  for i in range(0,int(s_NFactorial) +1):

   if(i == 0):
     i_ResultadoFactorial = 1
     print('>>> {}! = {}'.format(i, i_ResultadoFactorial) )    
    
   elif(i == 1):
     i_ResultadoFactorial = 1
     print('>>> {}! = {}'.format(i, i_ResultadoFactorial) )
      
   else:
     i_ResultadoFactorial = i * i_ResultadoFactorial
     print('>>> {}! = {}'.format(i, i_ResultadoFactorial) )

# Radar De Velocidad - Enunciado:

#Un radar común de detección de velocidad de la policía de caminos emite un rayo
#de microondas a una frecuencia f0. El rayo es reflejado por un automóvil que
#se aproxima y el rayo reflejado es captado y analizado por la unidad de radar.
#La frecuencia del rayo reflejado es cambiada ligeramente de f0 a f1 debido al
#movimiento del automóvil.

f_FrecuenciaInicial = 2 * 10 ** 10 #[sec ^–1]
f_FrecuenciaRecibida = 2.000004 * 10 ** 10 #[sec ^–1]
f_Velocidad = (6.685 * 10 ** 8) * (f_FrecuenciaRecibida - f_FrecuenciaInicial)/ (f_FrecuenciaRecibida + f_FrecuenciaInicial)

s_Linea = ''.center(50,'-')
s_Titulo = '{:^50}'.format('RADAR DE VELOCIDAD')
s_Mensaje = '>>> La velocidad es: %.2f millas/hora'%(f_Velocidad)

print(s_Linea + '\n')
print(s_Titulo + '\n')
print(s_Linea + '\n')
print( s_Mensaje + '\n' )
print(s_Linea + '\n')

# Distancia Recorrida por un Móvil - Enunciado:

#Se desea calcular la distancia recorrida (m) por un móvil que tiene velocidad
#constante (m/s) durante un tiempo t (s), considerar que es un MRU
#(Movimiento Rectilíneo Uniforme).

#Distancia = Velocidad x Tiempo

#Variables:


f_velocidad = .0 #metros/segundos
f_distancia = .0 #metros
f_tiempo = .0 #segundos

s_Linea = ''.center(50,'-')
s_Titulo = '{:^50}'.format('DISTANCIA DE UN MOVIL')
s_Linea = ''.center(50,'-')

print(s_Linea)
print(s_Titulo)
print(s_Linea)


f_velocidad = float( input('>>> Ingrese la Velocidad [m/s] : ') )
f_tiempo = float( input('>>> Ingrese el Tiempo [s]: ') )
f_distancia = f_velocidad * f_tiempo
s_Linea = ''.center(50,'-')

print(s_Linea)
s_Resultado = '{:^20}{:^20}'.format('DISTANCIA [m] :', f_distancia)
print(s_Resultado)
print(s_Linea)

# Velocidad de un Móvil - Enunciado

# Dado el tiempo en segundos y la distancia en metros de un móvil,
#ingresados por teclado, calcule la velocidad correspondiente.

#Se sabe que el cálculo de la velocidad en MRU es por fórmula:

#Velocidad = Distancia / Tiempo

f_velocidad = .0 #metros/segundos
f_distancia = .0 #metros
f_tiempo = .0 #segundos

s_Linea = ''.center(50,'-')
s_Titulo = '{:^50}'.format('VELOCIDAD DE UN MOVIL')
s_Linea = ''.center(50,'-')

print(s_Linea)
print(s_Titulo)
print(s_Linea)


f_distancia = float( input('>>> Ingrese la Distancia [m] : ') )
f_tiempo = float(input('>>> Ingrese el Tiempo [s]: ') )
f_velocidad = f_distancia / f_tiempo
s_Linea = ''.center(50,'-')

print(s_Linea)
s_Resultado = '{:^20} %.2f'%(f_velocidad)
print(s_Resultado.format('VELOCIDAD [m/s] :'))
print(s_Linea)

# Tiempo de Encuentro entre 2 Vehículos - Enunciado

# Desarrolla un Algoritmo, que calcule el tiempo de encuentro de 2 vehículos
#que van en sentido opuesto, teniendo como datos la distancia inicial que los
#separa y la velocidad de cada uno.

#Si las velocidades de ambos vehículos son iguales a 0, se debe mostrar un
#mensaje de error ya que si ninguno de los vehículos se está desplazando el
#tiempo de encuentro es infinito.

# La fórmula para calcular el tiempo de encuentro entre 2 vehículos es:
# Tiempo = Distancia / ( Velocidad1 + Velocidad2)

f_velocidad1 = .0 #metros/segundos
f_velocidad2 = .0 #metros/segundos
f_distancia = .0 #metros
f_tiempo = .0 #segundos

s_Linea = ''.center(50,'-')
s_Titulo = '{:^50}'.format('VELOCIDAD DE UN MOVIL')
s_Linea = ''.center(50,'-')

try:
  print(s_Linea)
  print(s_Titulo)
  print(s_Linea)
  
  f_distancia = float( input('>>> Distancia de separación [m] : ') )
  print(s_Linea)
  
  f_velocidad1 = float( input('>>> Velocidad del vehiculo 1 [m/s]: ') )
  f_velocidad2 = float( input('>>> Velocidad del vehiculo 2 [m/s]: ') )
  
  print(s_Linea)
  f_tiempo = f_distancia / (f_velocidad1 + f_velocidad2)


  s_Resultado = 'TIEMPO: %.2f [segundos]'%(f_tiempo)
  print(s_Resultado.center(50,' ') )
  print(s_Linea)

except ZeroDivisionError:
  print('\nERROR!')
  print('La velocidad de ambos vehiculos no puede ser cero')

except ValueError:
  print('\nERROR!')
  print('Solo se permiten números')

# Distancia entre 2 Puntos en el Plano - Enunciado

l_PuntoA, l_PuntoB = [0,0], [0,0]
f_Distancia = .0

s_Linea = ''.center(50,'-')
s_Titulo = '{:^50}'.format('DISTANCIA ENTRE 2 PUNTOS EN EL PLAN ')


try:
  print(s_Linea)
  print(s_Titulo)
  print(s_Linea)

  for Lista in range(0,2):
    if(Lista == 0):
      for ComponentesPuntos in range(0,2):
        if(ComponentesPuntos == 0):
          l_PuntoA[ComponentesPuntos] = input('>>> Ingrese la coordenada Ax: ')
        
        else:
          l_PuntoA[ComponentesPuntos] = input('>>> Ingrese la coordenada Ay: ')
    else:
      print(s_Linea)
      for ComponentesPuntos in range(0,2):
        if(ComponentesPuntos == 0):
          l_PuntoB[ComponentesPuntos] = input('>>> Ingrese la coordenada Bx: ')

        else:
          l_PuntoB[ComponentesPuntos] = input('>>> Ingrese la coordenada By: ')

  print(s_Linea)

  f_Distancia = ( ( float(l_PuntoA[0]) - float(l_PuntoB[0]) ) ** 2 + ( float(l_PuntoA[1]) - float(l_PuntoB[1]) ) ** 2 ) ** (1/2)
  s_Resultado = 'DISTANCIA: %.2f'%(f_Distancia)
  print(s_Resultado.center(50,' ') )
  print(s_Linea)

except:
  print('Error!\n')
  print('Solo se permiten números')

# Distancia entre 2 puntos en el espacio 3D - Enunciado

l_Punto1, l_Punto2 = [0,0,0], [0,0,0]
f_Distancia = .0

s_Linea = ''.center(50,'-')
s_Titulo = '{:^50}'.format('DISTANCIA ENTRE 2 PUNTOS EN EL ESPACIO ')


try:
  print(s_Linea)
  print(s_Titulo)
  print(s_Linea)

  for Lista in range(0,2):
    if(Lista == 0):
      for ComponentesPuntos in range(0,3):
        if(ComponentesPuntos == 0):
          l_Punto1[ComponentesPuntos] = input('>>> Ingrese la coordenada x1: ')

        elif(ComponentesPuntos == 1):
          l_Punto1[ComponentesPuntos] = input('>>> Ingrese la coordenada y1: ')

        else:
          l_Punto1[ComponentesPuntos] = input('>>> Ingrese la coordenada z1: ')
    else:
      print(s_Linea)
      for ComponentesPuntos in range(0,3):
        if(ComponentesPuntos == 0):
          l_Punto2[ComponentesPuntos] = input('>>> Ingrese la coordenada x2: ')

        elif(ComponentesPuntos == 1):
          l_Punto2[ComponentesPuntos] = input('>>> Ingrese la coordenada y2: ')

        else:
          l_Punto2[ComponentesPuntos] = input('>>> Ingrese la coordenada z2: ')

  print(s_Linea)

  f_Distancia = ( ( float(l_Punto1[0]) - float(l_Punto2[0]) ) ** 2 + ( float(l_Punto1[1]) - float(l_Punto2[1]) ) ** 2 + ( float(l_Punto1[2]) - float(l_Punto2[2]) ) ** 2) ** (1/2)
  s_Resultado = 'DISTANCIA: %.2f'%(f_Distancia)
  print(s_Resultado.center(50,' ') )
  print(s_Linea)

except:
  print('Error!\n')
  print('Solo se permiten números')

# Ecuación de Primer Grado - Enunciado

#Crear un Algoritmo que permita hallar la solución a una ecuación de primer
#grado, de la forma: ax + b = 0
#El objetivo es despejar la x y validar los posibles datos para arrojar la respuesta.

#Al despejar la x tendremos que:

#x = -b/a

#Por lo tanto tendremos los siguientes escenarios:

#1) Si a es DIFERENTE de 0 (a != 0) la ecuación tiene solución.
#2) Si a es IGUAL a 0 (a == 0) tendremos que:
#Si b es DIFERENTE de 0 (b != 0) la ecuación no tiene solución.
#Si b es IGUAL a 0 (b == 0) la ecuación tiene Infinitas Soluciones.

f_variable_x = .0
s_coeficiente_a = ''
s_coeficiente_b = ''

s_Linea = ''.center(50,'-')
s_Titulo = '{:^50}'.format('ECUACION DE PRIMER GRADO: ax + b = 0 ')


try:
  print(s_Linea)
  print(s_Titulo)
  print(s_Linea)

  s_coeficiente_a = input('>>> Valor de a: ')
  s_coeficiente_b = input('>>> Valor de b: ')
  
  if( float(s_coeficiente_a) != 0 ):
    print('\nComo "a" es diferente de cero la ecuación tiene solución')
    f_variable_x = - float(s_coeficiente_b) / float(s_coeficiente_a)
  else:
    if( float(s_coeficiente_b) != 0):
      print('\nComo a = 0 y b diferente de cero la ecuación no tiene solución')
    else:
      print('\nComo a = 0 y b = 0 la ecuación tiene infinitas soluciones')


  print(s_Linea)
  s_PresentacionEcuacion = 'ECUACION: {} x + ({}) = 0'.format( str(s_coeficiente_a), str(s_coeficiente_b) )
  print(s_PresentacionEcuacion)
  print(s_Linea)
  s_Resultado = '>>> SOLUCION: x = %.2f'%( f_variable_x )

  print(s_Resultado)
  print(s_Linea)

except:
  print('\nError!')
  print('Solo se permiten números')

# Ecuación de Segundo Grado - Enunciado

# Crear un Algoritmo que permita hallar la solución a una ecuación
#de segundo grado, de la forma:

f_variable_x1 = .0
f_variable_x2 = .0
s_coeficiente_a = ''
s_coeficiente_b = ''
s_coeficiente_c = ''
f_discriminante = .0

s_Linea = ''.center(50,'-')
s_Titulo = '{:^50}'.format('ECUACION DE PRIMER GRADO: ax^2 + bx + c = 0')


try:
  print(s_Linea)
  print(s_Titulo)
  print(s_Linea)

  s_coeficiente_a = input('>>> Valor de a: ')
  s_coeficiente_b = input('>>> Valor de b: ')
  s_coeficiente_c = input('>>> Valor de c: ')
  f_discriminante = (float(s_coeficiente_b)) ** 2 - 4 * float(s_coeficiente_a) * float(s_coeficiente_c)


  if( float(s_coeficiente_a) != 0 and f_discriminante >= 0):
    print('\nComo "a" es diferente de cero la ecuación tiene solución real')
    
    f_variable_x1 = ( - float(s_coeficiente_b) + ( f_discriminante ) ** (1/2) ) / ( 2 * float(s_coeficiente_a) )
    f_variable_x2 = ( - float(s_coeficiente_b) - ( f_discriminante ) ** (1/2) ) / ( 2 * float(s_coeficiente_a) )


    print(s_Linea)
    s_PresentacionEcuacion = 'ECUACION: {} x^2 + ({})x + {} = 0'.format( str(s_coeficiente_a), str(s_coeficiente_b), str(s_coeficiente_c) )
    print(s_PresentacionEcuacion)
    print(s_Linea)
    s_Resultado = '>>> SOLUCION: x1 = %4.2s y x2 = %4.2s'%( str(f_variable_x1), str(f_variable_x2) )

    print(s_Resultado)
    print(s_Linea)
  


  elif(float(s_coeficiente_a) != 0 and f_discriminante < 0):
    print('\nComo el discriminante es menor a cero la ecuación tiene soluciones imaginarias')
    
    f_variable_x1 = ( - float(s_coeficiente_b) + ( f_discriminante ) ** (1/2) ) / ( 2 * float(s_coeficiente_a) )
    f_variable_x2 = ( - float(s_coeficiente_b) - ( f_discriminante ) ** (1/2) ) / ( 2 * float(s_coeficiente_a) )


    print(s_Linea)
    s_PresentacionEcuacion = 'ECUACION: {} x^2 + ({})x + {} = 0'.format( str(s_coeficiente_a), str(s_coeficiente_b), str(s_coeficiente_c) )
    print(s_PresentacionEcuacion)
    print(s_Linea)
    s_Resultado = '>>> SOLUCION: x1 = {} y x2 = {}'.format( f_variable_x1, f_variable_x2 )

    print(s_Resultado)
    print(s_Linea)

  elif(float(s_coeficiente_a) == 0 and float(s_coeficiente_b) == 0):
    print(s_Linea)
    s_PresentacionEcuacion = 'ECUACION: {} x^2 + ({})x + {} = 0'.format( str(s_coeficiente_a), str(s_coeficiente_b), str(s_coeficiente_c) )
    print(s_PresentacionEcuacion)
    print(s_Linea)
    
    print('\nLa ecuación no tiene solución')

  else:
    print(s_Linea)
    s_PresentacionEcuacion = 'ECUACION: {} x^2 + ({})x + {} = 0'.format( str(s_coeficiente_a), str(s_coeficiente_b), str(s_coeficiente_c) )
    print(s_PresentacionEcuacion)
    print(s_Linea)

    print('\nLa ecuación no es de segundo grado sino de primer grado')


except ZeroDivisionError:
  print('\nError, División por cero!')
  print('Como b = 0 la ecuación tiene infinitas soluciones')

except ValueError:
  print('\nError!')
  print('Solo se permiten números')

# Interés Compuesto - Enunciado

# Se coloca un capital, a un interés que oscila entre 0 y 100, durante
#cierta cantidad de años y se desea saber en cuanto se habrá convertido ese
#capital en cierta cantidad de años, sabiendo que es acumulativo.

f_CapitalInicial = .0
f_Interes = .0
f_TiempoAños = .0

s_Linea = ''.center(50,'-')
s_Titulo = '{:^50}'.format('INTERES COMPUESTO (USD)')

#try:
print(s_Linea)
print(s_Titulo)
print(s_Linea)
  
f_CapitalInicial = float(input('>>> Capital Inicial: '))
f_Interes = float(input('>>> Porcentaje de interes: ')) / 100
f_TiempoAños = float(input('>>> Tiempo en Años: '))
  
print(s_Linea)
f_InteresCompuesto = f_CapitalInicial * ( 1 + f_Interes ) ** f_TiempoAños
s_CapitalTotal = 'CAPITAL TOTAL: %.2f'%(f_InteresCompuesto)
print(s_CapitalTotal.center(50,' ') )
print(s_Linea)
#except:
 # print('\nError!')
  #print('Solo se permiten números')

# Matrices - Enunciado

# Crea una Matriz 4x4 que almacene los valores de un teclado matricial.
#Imprime la matriz, la cuarta fila y el asterisco (*) en pantalla.

l_Matriz = [[1, 2, 3, 4, 'A'], [4, 5, 6, 'B'], 
            [7 , 8, 9, 'C'], [ '*', 0, '#', 'D']]

print('>>> IMPRIMIR MATRIZ: {}'.format( l_Matriz ) )

print('>>> FILA A IMPRIMIR : {}'.format( l_Matriz[3] ) )

print('>>> DATO A IMPRIMIR : {}'.format( l_Matriz[3][0] ) )

# Dimensión de una Matriz - Enunciado

# Crea una matriz 3x3 que almacene los valores del 1 al 9. El tamaño de la
#matriz indica la cantidad de filas. Imprime cada fila de la matriz en pantalla.

l_Matriz = [ [7, 8, 9], [4, 5, 6], 
            [1 , 2, 3] ]

print('>>> IMPRIMIR MATRIZ: {}\n'.format( l_Matriz ) )

print('>>> FILA 1: {}'.format( l_Matriz[0] ) )

print('>>> FILA 2: {}'.format( l_Matriz[1] ) )

print('>>> FILA 3: {}'.format( l_Matriz[2] ) )

print('\n>>> LONGITUD DE FILAS: {} \n>>> LONGITUD DE COLUMNAS: {}'.format( len(l_Matriz), len(l_Matriz[0])) )

#Creación de Matrices: Matriz Nula - Enunciado:

#Haz un programa para crear una matriz nula Mmxn, donde se le solicite al
#usuario su dimensión m x n, (m son las filas y n son las columnas). Imprime 
#cada fila de la matriz en pantalla.
i_DimensionN = 0
i_DimensionM = 0
l_Matriz = []
try:
  i_DimensionN = int(input('>>> N° DE FILAS: ') )
  i_DimensionM = int(input('>>> N° DE COLUMNAS: ') )
  for filas in range(i_DimensionN):
    l_Matriz.append([0] * i_DimensionM)
  
  print('\n2>>> MATRIZ M({}x{}): {}\n'.format( i_DimensionN , i_DimensionM , l_Matriz ) )

  for fila in range(0, i_DimensionN):
    print('>>> FILA {} : {}'.format( fila+1 , l_Matriz[fila] ) )


except:
  print('ERROR!')
  print('Solo se permite ingresar números')

#Creación de matrices: Matriz Identidad - Enunciado

#Haz un programa que pida un entero positivo n y almacene en una variable 
#la matriz identidad de n × n (la que tiene unos (1) en la diagonal principal
#y ceros (0) en el resto de celdas). Imprime la matriz en pantalla.

i_DimensionN = 0
l_Matriz = []
try:

  i_DimensionN = int(input('>>> N° DE FILAS: ') )

  if(i_DimensionN > 0):
        
    for filas in range(i_DimensionN):
      l_Matriz.append([0] * i_DimensionN)
    
    for fila in range(i_DimensionN):
      for columna in range(i_DimensionN):
        if(fila == columna):
          l_Matriz[fila][columna] = 1
    print('\n>>> MATRIZ M({}x{}): {}\n'.format( i_DimensionN , i_DimensionN , l_Matriz ) )

    for fila in range(0, i_DimensionN):
      print('>>> FILA {} : {}'.format( fila+1 , l_Matriz[fila] ) ) 
  
  else:
    print('El número ingresado no es un entero positivo')

except:
  print('ERROR!')
  print('Solo se permite ingresar números')

#Lectura de Matrices: Llenar una Matriz por Teclado - Enunciado

# Haz un programa que permita crear una matriz, solicitando por teclado el
# número de filas y columnas, como asi tambien, los elementos a ingresar en la
#matriz

i_DimensionN = 0
i_DimensionM = 0
l_Matriz = []
try:
  i_DimensionN = int(input('>>> N° DE FILAS: ') )
  i_DimensionM = int(input('>>> N° DE COLUMNAS: ') )
  print(" ")

  if(i_DimensionN > 0 and i_DimensionM > 0):
        
    for filas in range(i_DimensionN):
      l_Matriz.append([0] * i_DimensionM)

    for fila in range(0, i_DimensionN):
      for columna in range(i_DimensionM):
        l_Matriz[fila][columna] = float( input('Cargue elemento [{} {}] de la matriz: '.format(fila+1, columna+1)) )

    print('\n>>> MATRIZ M({}x{}): {}\n'.format( i_DimensionN , i_DimensionM , l_Matriz ) )

    for fila in range(0, i_DimensionN):
      print('>>> FILA {} : {}'.format( fila+1 , l_Matriz[fila] ) )

  else:
    print('El número ingresado no es un entero positivo')

except:
  print('ERROR!')
  print('Solo se permite ingresar números')

# Matriz Transpuesta - Enunciado

i_DimensionN = 0
i_DimensionM = 0
l_Matriz = []
l_MatrizTranspuesta = []
try:
  i_DimensionN = int(input('>>> N° DE FILAS: ') )
  i_DimensionM = int(input('>>> N° DE COLUMNAS: ') )
  print(" ")

  if(i_DimensionN > 0 and i_DimensionM > 0):

    #Creacion y carga de la matriz    
    for filas in range(i_DimensionN):
      l_Matriz.append([0] * i_DimensionM)

    for fila in range(i_DimensionN):
      for columna in range(i_DimensionM):
        l_Matriz[fila][columna] = float( input('Cargue elemento [{} {}] de la matriz: '.format(fila+1, columna+1)) )
     #   l_MatrizTranspuesta[columna][fila] = l_Matriz[fila][columna]

    # definición de matriz transpuesta
    for fila in range(i_DimensionM):
      l_MatrizTranspuesta.append([0] * i_DimensionN)

    for fila in range(i_DimensionN):
      for columna in range(i_DimensionM):
        l_MatrizTranspuesta[columna][fila] = l_Matriz[fila][columna]

    print('\n>>> MATRIZ ORIGINAL:\n')
    
    for fila in range(0, len(l_Matriz)):
      print('{}'.format( l_Matriz[fila] ) )

    print('\n>>> MATRIZ TRANSPUESTA:\n')
    
    for fila in range(0, len(l_MatrizTranspuesta)):
      print('{}'.format( l_MatrizTranspuesta[fila] ) )   

  else:
    print('El número ingresado para las filas / columnas no es un entero positivo')

except:
  print('ERROR!')
  print('Solo se permite ingresar números')

# Función para generar una Matriz - Enunciado

# Desarrolla una función llamada “crear_array” que reciba un parámetro llamado
#"lista" que va a almacenar los elementos contenidos en la lista  para ser
#trasformados en un array o matriz.

# La función debe permitir transformar los elementos de una lista de listas y
#devolver los mismos valores para ser guardados en una variable llamada “array”
#la cual será una lista vacía hasta recibir los elementos de la función
#“crear array”.

#Variables
l_lista = [[1, 2, 3],[4, 5, 6], [7, 8, 9]]


def l_crear_array (l_listFuncion):
  l_listaAuxiliar = []

  for fila in range(len(l_listFuncion)):
    l_listaAuxiliar.append(l_listFuncion[fila])

  return l_listaAuxiliar

array = l_crear_array( l_lista )

print(array)

# Función para transformar una lista en una Matriz - Enunciado

#La función debe permitir transformar los elementos de una lista simple en
#elementos de una matriz agrupándolos en filas y columnas. la función debe
#devolver la nueva lista y guardarla en una variable llamada “matriz”.

i_fila = 4
i_columna = 4

l_Matriz = []

l_NuevaLista = ['a', 'b', 'c', 'd', 'e',
                'f', 'g', 'h', 'i', 'j',
                'k', 'l', 'm', 'n', 'o',
                'p', 'q', 'r', 's', 't',
                'u', 'v', 'w', 'x', 'y'
                ]

def l_crear_matriz(NFilas, MColumnas,l_listaFuncion):
  l_listaAuxiliar = []

  for fila in range(NFilas):
    l_listaAuxiliar.append( [0] * MColumnas )

  for fila in range(NFilas):
    for columna in range(MColumnas):
      l_listaAuxiliar[fila][columna] = l_listaFuncion[NFilas * fila + columna]

  return l_listaAuxiliar

l_Matriz = l_crear_matriz (i_fila, i_columna, l_NuevaLista)
print(l_Matriz)

#Suma de Matrices - Enunciado

# Diseñar un programa que sume dos matrices. Recuerda que solo es posible sumar
#matrices con la misma dimensión, con la misma cantidad de Filas y Columnas.
# Hemos de tener claro cómo se calcula C = A + B. Si la dimensión de A y de B
#es m × n, la matriz resultante será de esa misma dimensión, y su elemento de
#coordenadas (i, j), es decir, Ci,j , se calcula así:

#Ci,j = Ai,j + Bi,j

#Para 1 ≤ i ≤ m y 1 ≤ j ≤ n. Recuerda que la convención adoptada en la notación
#matemática hace que los índices de las matrices empiecen en 1, pero que en
#Python todo empieza en 0.

l_MatrizA, l_MatrizB, l_MatrizC = [], [], [] 

try:
  i_DimensionN = int(input('>>> N° DE FILAS: ') )
  i_DimensionM = int(input('>>> N° DE COLUMNAS: ') )
  print(" ")

  if(i_DimensionN > 0 and i_DimensionM > 0):

    #Definición de las matrices A, B y C 
    for filas in range(i_DimensionN):
      l_MatrizA.append([0] * i_DimensionM)
      l_MatrizB.append([0] * i_DimensionM)
      l_MatrizC.append([0] * i_DimensionM)      

    # Carga de las matrices A y B

    for fila in range(i_DimensionN):
      for columna in range(i_DimensionM):
        l_MatrizA[fila][columna] = float( input('Cargue elemento [{} {}] de la matriz A: '.format(fila+1, columna+1)) )
  
    print(" ")
    
    for fila in range(i_DimensionN):
      for columna in range(i_DimensionM):
        l_MatrizB[fila][columna] = float( input('Cargue elemento [{} {}] de la matriz B: '.format(fila+1, columna+1)) )

    # Calculo de matriz C = A + B
    
    for fila in range(i_DimensionN):
      for columna in range(i_DimensionM):
        l_MatrizC[fila][columna] = l_MatrizA[fila][columna] + l_MatrizB[fila][columna]

    print('\n>>> MATRIZ A:\n')
    
    for fila in range(0, len(l_MatrizA)):
      print('{}'.format( l_MatrizA[fila] ) )

    print('\n>>> MATRIZ B:\n')
    for fila in range(0, len(l_MatrizB)):
      print('{}'.format( l_MatrizB[fila] ) )

    print('\n>>> MATRIZ C = A + B:\n')
    
    for fila in range(0, len(l_MatrizC)):
      print('{}'.format( l_MatrizC[fila] ) )   

  else:
    print('El número ingresado para las filas / columnas no es un entero positivo')

except:
  print('ERROR!')
  print('Solo se permite ingresar números')

#Sistema de Ecuaciones (Método de Cramer) - Enunciado

#Usando estas ecuaciones, escriba, y ejecute un programa para encontrar
#los valores x1 y x2 que satisfagan las siguientes ecuaciones:
# 3x1 + 4x2 = 40 ; 5x1 + 2x2 = 34

a11, a12, c1 = .0, .0, .0 # coeficientes de 1era ecuacion

a21, a22, c2 = .0, .0, .0 # coeficientes de 2da ecuacion

x1, x2 = .0, .0 #variables de las ecuaciones

s_Linea = ''.center(50,'-')
s_Titulo = '{:^50}'.format('SISTEMA DE ECUACIONES: METODO DE CRAMER')
s_ecuacion1 = 'a11*x1 + a12*x2 = c1'
s_ecuacion2 = 'a21*x1 + a22*x2 = c2'

try:
  print(s_Linea)
  print(s_Titulo)
  print(' ')
  print(s_ecuacion1.center(50,' '))
  print(s_ecuacion2.center(50,' '))
  print(s_Linea)

  a11 = float(input('>>> Valor de a11: ') )
  a12 = float(input('>>> Valor de a12: ') )
  c1 = float(input('>>> Valor de c1: ') )
  print(' ')
  
  a21 = float(input('>>> Valor de a21: ') )
  a22 = float(input('>>> Valor de a22: ') )
  c2 = float(input('>>> Valor de c2: ') )

  print(s_Linea)
  s_PresentacionEcuacion1 = '({})*x1 + ({})*x2 = {}'.format(a11, a12, c1)
  s_PresentacionEcuacion2 = '({})*x1 + ({})*x2 = {}'.format(a21, a22, c2)

  print('{:^50}'.format('ECUACIONES'))
  print(' ')
  print(s_PresentacionEcuacion1.center(50,' ') )
  print(s_PresentacionEcuacion2.center(50,' ') )
  print(s_Linea)

  #calculo de x1, x2
  x1 = (c1 * a22 - c2 * a12) / (a11 * a22 - a12 * a21)
  x2 = (c2 * a11 - c1 * a21) / (a11 * a22 - a12 * a21)

  print('{:^50}'.format('SOLUCION'))
  print(' ')
  s_resultado = 'x1 = %.2f ^ x2 = %.2f'%(x1,x2)
  print(s_resultado.center(50,' '))

except:
  print('ERROR!')
  print('Solo se permite ingresar números')

# Determinante de una Matriz (Regla de Sarrus) - Enunciado

# Escriba, y ejecute un programa para calcular el determinante de una matriz 3x3.


s_Linea = ''.center(50,'-')
s_Titulo = '{:^50}'.format('DETERMINANTE - MATRIZ 3x3: REGLA DE SARRUS')
s_Matriz = '{:^50}'.format('MATRIZ INGRESADA')
i_NFilas = 3
i_MColumnas = 3
l_MatrizA = []

try:
  print(s_Linea)
  print(s_Titulo)
  print(s_Linea)

  for filas in range(i_NFilas):
    l_MatrizA.append([0] * i_MColumnas)

  for filas in range(i_NFilas):
    for columnas in range(i_MColumnas):
      l_MatrizA[filas][columnas] = float(input('Ingrese elemento a[%d;%d]: '%(filas,columnas)))
  
  print(s_Linea)
  print(s_Matriz)
  print(s_Linea)

  for filas in range(i_NFilas):
    print(str(l_MatrizA[filas]).center(50,' '))

  print(s_Linea)

  #Calculo de determinante
  a11, a12, a13 = l_MatrizA[0][0], l_MatrizA[0][1], l_MatrizA[0][2]
  a21, a22, a23 = l_MatrizA[1][0], l_MatrizA[1][1], l_MatrizA[1][2]
  a31, a32, a33 = l_MatrizA[2][0], l_MatrizA[2][1], l_MatrizA[2][2]

  f_determinante = a11*(a22*a33-a32*a23) - a12*(a21*a33-a31*a23) + a13*(a21*a32-a31*a22)

  print('{:^50}'.format('RESULTADO'))
  print(s_Linea)

  s_resultado = '|A| = %.2f'%(f_determinante)
  print(s_resultado.center(50,' '))
  print(s_Linea)

   
except:
  print('ERROR!')
  print('Solo se permite ingresar números')

#x = float (input('ingrese num x: '))
#y = float (input('ingrese num y: '))
#a = float (input('ingrese num a: '))
#b = float (input('ingrese num b: '))


#print('el resultado de x>y or a>b es: {}'.format(x > y or a > b) )

#x = input('ingrese texto: ')
#y = input('ingrese texto: ')

#print( x >= y )



#print(10 in list1)

#x = int( input('ingrese dato: ') )

#list1.append( x )

#print( len(list1) )

#if x in list1:
  #print(str(x)+ ' está en la lista1')

#for i in list1:
 # print( 'List1: {}'.format(i) )

list1 = [2,3,4,5]
list2 = [6,7,8]

#x = input('ingrese texto: ')
#y = int( input('ingrese la posición: ') )

#x = x.split(',')
#list1.pop( x )

#list1.insert(y,x)

#list1.clear()

#x = ','.join(x)

#print( sum(list1) )

#dic1={'10':'Messi','14':'Mascherano','1':'Martinez'}

#print('{}, {}, {} '.format(dic1['10'], dic1['14'], dic1['1'] ) )


#print(dic1)

#dic2=dict()
#dic3={}
#print('{}, {}, {} '.format(dic1['Messi'], dic1['Mascherano'], dic1['Martinez'] ) )

#print(type(dic2))
#print(dic3)

#dic1['Messi']='24'

#for a,b in dic1.items():
 # print( a,b )

#dic1={'Messi':20,'Mascherano':14,'Martinez':1}
#dic2 = {} 
#dic2 = dic1.copy()

#dic2 = dict( dic1 )

#dic1.popitem()

dic1 = {'1':[12,15,18], 'Km':'hola'}
print( type(dic1['Km']) )
#print(dic2)

a,b,c,d = input('ingrese clave 1: '), input('ingrese clave 2: '), input('ingrese clave 3: '), input('ingrese clave 4: ')
v1,v2,v3,v4 = float(input('ingrese valor 1: ')), float(input('ingrese valor 2: ')), float(input('ingrese valor 3: ')), float(input('ingrese valor 4: '))
dicc=dict(a=v1, b=v2, c=v3, d=v4)

#print(dicc)

print('Las claves son: {}'.format( dicc.keys() ) )
print('Las valores son: {}'.format( dicc.values() ) )

informatica = ['juan', 'pepe', 'luis']
dibujo_tec = ['pepe', 'pedro', 'marcos']
ingles = ['pedro', 'juan','luis']

alumnos = set(informatica + dibujo_tec + ingles)

print(alumnos)
print(len(alumnos))